/* Autogenerated by mlir-tblgen; don't manually edit */

#ifdef GEN_PASS_DECL
// Generate declarations for all passes.
#define GEN_PASS_DECL_ABSTRACTRESULTONFUNCOPT
#define GEN_PASS_DECL_ABSTRACTRESULTONGLOBALOPT
#define GEN_PASS_DECL_ADDDEBUGFOUNDATION
#define GEN_PASS_DECL_AFFINEDIALECTDEMOTION
#define GEN_PASS_DECL_AFFINEDIALECTPROMOTION
#define GEN_PASS_DECL_ALGEBRAICSIMPLIFICATION
#define GEN_PASS_DECL_ANNOTATECONSTANTOPERANDS
#define GEN_PASS_DECL_ARRAYVALUECOPY
#define GEN_PASS_DECL_CFGCONVERSION
#define GEN_PASS_DECL_CHARACTERCONVERSION
#define GEN_PASS_DECL_EXTERNALNAMECONVERSION
#define GEN_PASS_DECL_LOOPVERSIONING
#define GEN_PASS_DECL_MEMREFDATAFLOWOPT
#define GEN_PASS_DECL_MEMORYALLOCATIONOPT
#define GEN_PASS_DECL_OMPEARLYOUTLININGPASS
#define GEN_PASS_DECL_OMPFUNCTIONFILTERING
#define GEN_PASS_DECL_OMPMARKDECLARETARGETPASS
#define GEN_PASS_DECL_POLYMORPHICOPCONVERSION
#define GEN_PASS_DECL_SIMPLIFYINTRINSICS
#define GEN_PASS_DECL_SIMPLIFYREGIONLITE
#define GEN_PASS_DECL_STACKARRAYS
#undef GEN_PASS_DECL
#endif // GEN_PASS_DECL

//===----------------------------------------------------------------------===//
// AbstractResultOnFuncOpt
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_ABSTRACTRESULTONFUNCOPT
struct AbstractResultOnFuncOptOptions {
  bool passResultAsBox = false;
};
#undef GEN_PASS_DECL_ABSTRACTRESULTONFUNCOPT
#endif // GEN_PASS_DECL_ABSTRACTRESULTONFUNCOPT
#ifdef GEN_PASS_DEF_ABSTRACTRESULTONFUNCOPT
namespace impl {

template <typename DerivedT>
class AbstractResultOnFuncOptBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = AbstractResultOnFuncOptBase;

  AbstractResultOnFuncOptBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  AbstractResultOnFuncOptBase(const AbstractResultOnFuncOptBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("abstract-result-on-func-opt");
  }
  ::llvm::StringRef getArgument() const override { return "abstract-result-on-func-opt"; }

  ::llvm::StringRef getDescription() const override { return "Convert fir.array, fir.box and fir.rec function result to function argument"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("AbstractResultOnFuncOpt");
  }
  ::llvm::StringRef getName() const override { return "AbstractResultOnFuncOpt"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<fir::FIROpsDialect>();

  registry.insert<mlir::func::FuncDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(AbstractResultOnFuncOptBase<DerivedT>)

  AbstractResultOnFuncOptBase(const AbstractResultOnFuncOptOptions &options) : AbstractResultOnFuncOptBase() {
    passResultAsBox = options.passResultAsBox;
  }
protected:
  ::mlir::Pass::Option<bool> passResultAsBox{*this, "abstract-result-as-box", ::llvm::cl::desc("Pass fir.array<T> result as fir.box<fir.array<T>> argument instead of fir.ref<fir.array<T>>."), ::llvm::cl::init(false)};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_ABSTRACTRESULTONFUNCOPT
#endif // GEN_PASS_DEF_ABSTRACTRESULTONFUNCOPT

//===----------------------------------------------------------------------===//
// AbstractResultOnGlobalOpt
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_ABSTRACTRESULTONGLOBALOPT
struct AbstractResultOnGlobalOptOptions {
  bool passResultAsBox = false;
};
#undef GEN_PASS_DECL_ABSTRACTRESULTONGLOBALOPT
#endif // GEN_PASS_DECL_ABSTRACTRESULTONGLOBALOPT
#ifdef GEN_PASS_DEF_ABSTRACTRESULTONGLOBALOPT
namespace impl {

template <typename DerivedT>
class AbstractResultOnGlobalOptBase : public ::mlir::OperationPass<fir::GlobalOp> {
public:
  using Base = AbstractResultOnGlobalOptBase;

  AbstractResultOnGlobalOptBase() : ::mlir::OperationPass<fir::GlobalOp>(::mlir::TypeID::get<DerivedT>()) {}
  AbstractResultOnGlobalOptBase(const AbstractResultOnGlobalOptBase &other) : ::mlir::OperationPass<fir::GlobalOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("abstract-result-on-global-opt");
  }
  ::llvm::StringRef getArgument() const override { return "abstract-result-on-global-opt"; }

  ::llvm::StringRef getDescription() const override { return "Convert fir.array, fir.box and fir.rec function result to function argument"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("AbstractResultOnGlobalOpt");
  }
  ::llvm::StringRef getName() const override { return "AbstractResultOnGlobalOpt"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<fir::FIROpsDialect>();

  registry.insert<mlir::func::FuncDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(AbstractResultOnGlobalOptBase<DerivedT>)

  AbstractResultOnGlobalOptBase(const AbstractResultOnGlobalOptOptions &options) : AbstractResultOnGlobalOptBase() {
    passResultAsBox = options.passResultAsBox;
  }
protected:
  ::mlir::Pass::Option<bool> passResultAsBox{*this, "abstract-result-as-box", ::llvm::cl::desc("Pass fir.array<T> result as fir.box<fir.array<T>> argument instead of fir.ref<fir.array<T>>."), ::llvm::cl::init(false)};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_ABSTRACTRESULTONGLOBALOPT
#endif // GEN_PASS_DEF_ABSTRACTRESULTONGLOBALOPT

//===----------------------------------------------------------------------===//
// AddDebugFoundation
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_ADDDEBUGFOUNDATION
#undef GEN_PASS_DECL_ADDDEBUGFOUNDATION
#endif // GEN_PASS_DECL_ADDDEBUGFOUNDATION
#ifdef GEN_PASS_DEF_ADDDEBUGFOUNDATION
namespace impl {

template <typename DerivedT>
class AddDebugFoundationBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = AddDebugFoundationBase;

  AddDebugFoundationBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  AddDebugFoundationBase(const AddDebugFoundationBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("add-debug-foundation");
  }
  ::llvm::StringRef getArgument() const override { return "add-debug-foundation"; }

  ::llvm::StringRef getDescription() const override { return "Add the foundation for debug info"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("AddDebugFoundation");
  }
  ::llvm::StringRef getName() const override { return "AddDebugFoundation"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<fir::FIROpsDialect>();

  registry.insert<mlir::func::FuncDialect>();

  registry.insert<mlir::LLVM::LLVMDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(AddDebugFoundationBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_ADDDEBUGFOUNDATION
#endif // GEN_PASS_DEF_ADDDEBUGFOUNDATION

//===----------------------------------------------------------------------===//
// AffineDialectDemotion
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_AFFINEDIALECTDEMOTION
#undef GEN_PASS_DECL_AFFINEDIALECTDEMOTION
#endif // GEN_PASS_DECL_AFFINEDIALECTDEMOTION
#ifdef GEN_PASS_DEF_AFFINEDIALECTDEMOTION
namespace impl {

template <typename DerivedT>
class AffineDialectDemotionBase : public ::mlir::OperationPass<::mlir::func::FuncOp> {
public:
  using Base = AffineDialectDemotionBase;

  AffineDialectDemotionBase() : ::mlir::OperationPass<::mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  AffineDialectDemotionBase(const AffineDialectDemotionBase &other) : ::mlir::OperationPass<::mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("demote-affine");
  }
  ::llvm::StringRef getArgument() const override { return "demote-affine"; }

  ::llvm::StringRef getDescription() const override { return "Converts `affine.{load,store}` back to fir operations"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("AffineDialectDemotion");
  }
  ::llvm::StringRef getName() const override { return "AffineDialectDemotion"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<fir::FIROpsDialect>();

  registry.insert<mlir::func::FuncDialect>();

  registry.insert<mlir::affine::AffineDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(AffineDialectDemotionBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_AFFINEDIALECTDEMOTION
#endif // GEN_PASS_DEF_AFFINEDIALECTDEMOTION

//===----------------------------------------------------------------------===//
// AffineDialectPromotion
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_AFFINEDIALECTPROMOTION
#undef GEN_PASS_DECL_AFFINEDIALECTPROMOTION
#endif // GEN_PASS_DECL_AFFINEDIALECTPROMOTION
#ifdef GEN_PASS_DEF_AFFINEDIALECTPROMOTION
namespace impl {

template <typename DerivedT>
class AffineDialectPromotionBase : public ::mlir::OperationPass<::mlir::func::FuncOp> {
public:
  using Base = AffineDialectPromotionBase;

  AffineDialectPromotionBase() : ::mlir::OperationPass<::mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  AffineDialectPromotionBase(const AffineDialectPromotionBase &other) : ::mlir::OperationPass<::mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("promote-to-affine");
  }
  ::llvm::StringRef getArgument() const override { return "promote-to-affine"; }

  ::llvm::StringRef getDescription() const override { return "Promotes `fir.{do_loop,if}` to `affine.{for,if}`."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("AffineDialectPromotion");
  }
  ::llvm::StringRef getName() const override { return "AffineDialectPromotion"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<fir::FIROpsDialect>();

  registry.insert<mlir::func::FuncDialect>();

  registry.insert<mlir::affine::AffineDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(AffineDialectPromotionBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_AFFINEDIALECTPROMOTION
#endif // GEN_PASS_DEF_AFFINEDIALECTPROMOTION

//===----------------------------------------------------------------------===//
// AlgebraicSimplification
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_ALGEBRAICSIMPLIFICATION
#undef GEN_PASS_DECL_ALGEBRAICSIMPLIFICATION
#endif // GEN_PASS_DECL_ALGEBRAICSIMPLIFICATION
#ifdef GEN_PASS_DEF_ALGEBRAICSIMPLIFICATION
namespace impl {

template <typename DerivedT>
class AlgebraicSimplificationBase : public ::mlir::OperationPass<> {
public:
  using Base = AlgebraicSimplificationBase;

  AlgebraicSimplificationBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  AlgebraicSimplificationBase(const AlgebraicSimplificationBase &other) : ::mlir::OperationPass<>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("flang-algebraic-simplification");
  }
  ::llvm::StringRef getArgument() const override { return "flang-algebraic-simplification"; }

  ::llvm::StringRef getDescription() const override { return ""; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("AlgebraicSimplification");
  }
  ::llvm::StringRef getName() const override { return "AlgebraicSimplification"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<mlir::math::MathDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(AlgebraicSimplificationBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_ALGEBRAICSIMPLIFICATION
#endif // GEN_PASS_DEF_ALGEBRAICSIMPLIFICATION

//===----------------------------------------------------------------------===//
// AnnotateConstantOperands
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_ANNOTATECONSTANTOPERANDS
#undef GEN_PASS_DECL_ANNOTATECONSTANTOPERANDS
#endif // GEN_PASS_DECL_ANNOTATECONSTANTOPERANDS
#ifdef GEN_PASS_DEF_ANNOTATECONSTANTOPERANDS
namespace impl {

template <typename DerivedT>
class AnnotateConstantOperandsBase : public ::mlir::OperationPass<> {
public:
  using Base = AnnotateConstantOperandsBase;

  AnnotateConstantOperandsBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  AnnotateConstantOperandsBase(const AnnotateConstantOperandsBase &other) : ::mlir::OperationPass<>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("annotate-constant");
  }
  ::llvm::StringRef getArgument() const override { return "annotate-constant"; }

  ::llvm::StringRef getDescription() const override { return "Annotate constant operands to all FIR operations"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("AnnotateConstantOperands");
  }
  ::llvm::StringRef getName() const override { return "AnnotateConstantOperands"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<fir::FIROpsDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(AnnotateConstantOperandsBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_ANNOTATECONSTANTOPERANDS
#endif // GEN_PASS_DEF_ANNOTATECONSTANTOPERANDS

//===----------------------------------------------------------------------===//
// ArrayValueCopy
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_ARRAYVALUECOPY
struct ArrayValueCopyOptions {
  bool optimizeConflicts = false;
};
#undef GEN_PASS_DECL_ARRAYVALUECOPY
#endif // GEN_PASS_DECL_ARRAYVALUECOPY
#ifdef GEN_PASS_DEF_ARRAYVALUECOPY
namespace impl {

template <typename DerivedT>
class ArrayValueCopyBase : public ::mlir::OperationPass<::mlir::func::FuncOp> {
public:
  using Base = ArrayValueCopyBase;

  ArrayValueCopyBase() : ::mlir::OperationPass<::mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  ArrayValueCopyBase(const ArrayValueCopyBase &other) : ::mlir::OperationPass<::mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("array-value-copy");
  }
  ::llvm::StringRef getArgument() const override { return "array-value-copy"; }

  ::llvm::StringRef getDescription() const override { return "Convert array value operations to memory operations."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ArrayValueCopy");
  }
  ::llvm::StringRef getName() const override { return "ArrayValueCopy"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<fir::FIROpsDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ArrayValueCopyBase<DerivedT>)

  ArrayValueCopyBase(const ArrayValueCopyOptions &options) : ArrayValueCopyBase() {
    optimizeConflicts = options.optimizeConflicts;
  }
protected:
  ::mlir::Pass::Option<bool> optimizeConflicts{*this, "optimize-conflicts", ::llvm::cl::desc("do more detailed conflict analysis to reduce the number of temporaries"), ::llvm::cl::init(false)};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_ARRAYVALUECOPY
#endif // GEN_PASS_DEF_ARRAYVALUECOPY

//===----------------------------------------------------------------------===//
// CFGConversion
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_CFGCONVERSION
struct CFGConversionOptions {
  bool forceLoopToExecuteOnce = false;
};
#undef GEN_PASS_DECL_CFGCONVERSION
#endif // GEN_PASS_DECL_CFGCONVERSION
#ifdef GEN_PASS_DEF_CFGCONVERSION
namespace impl {

template <typename DerivedT>
class CFGConversionBase : public ::mlir::OperationPass<::mlir::func::FuncOp> {
public:
  using Base = CFGConversionBase;

  CFGConversionBase() : ::mlir::OperationPass<::mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  CFGConversionBase(const CFGConversionBase &other) : ::mlir::OperationPass<::mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("cfg-conversion");
  }
  ::llvm::StringRef getArgument() const override { return "cfg-conversion"; }

  ::llvm::StringRef getDescription() const override { return "Convert FIR structured control flow ops to CFG ops."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("CFGConversion");
  }
  ::llvm::StringRef getName() const override { return "CFGConversion"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<fir::FIROpsDialect>();

  registry.insert<mlir::func::FuncDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(CFGConversionBase<DerivedT>)

  CFGConversionBase(const CFGConversionOptions &options) : CFGConversionBase() {
    forceLoopToExecuteOnce = options.forceLoopToExecuteOnce;
  }
protected:
  ::mlir::Pass::Option<bool> forceLoopToExecuteOnce{*this, "always-execute-loop-body", ::llvm::cl::desc("force the body of a loop to execute at least once"), ::llvm::cl::init(false)};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_CFGCONVERSION
#endif // GEN_PASS_DEF_CFGCONVERSION

//===----------------------------------------------------------------------===//
// CharacterConversion
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_CHARACTERCONVERSION
struct CharacterConversionOptions {
  std::string useRuntimeCalls = std::string{};
};
#undef GEN_PASS_DECL_CHARACTERCONVERSION
#endif // GEN_PASS_DECL_CHARACTERCONVERSION
#ifdef GEN_PASS_DEF_CHARACTERCONVERSION
namespace impl {

template <typename DerivedT>
class CharacterConversionBase : public ::mlir::OperationPass<> {
public:
  using Base = CharacterConversionBase;

  CharacterConversionBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  CharacterConversionBase(const CharacterConversionBase &other) : ::mlir::OperationPass<>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("character-conversion");
  }
  ::llvm::StringRef getArgument() const override { return "character-conversion"; }

  ::llvm::StringRef getDescription() const override { return "Convert CHARACTER entities with different KINDs"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("CharacterConversion");
  }
  ::llvm::StringRef getName() const override { return "CharacterConversion"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<fir::FIROpsDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(CharacterConversionBase<DerivedT>)

  CharacterConversionBase(const CharacterConversionOptions &options) : CharacterConversionBase() {
    useRuntimeCalls = options.useRuntimeCalls;
  }
protected:
  ::mlir::Pass::Option<std::string> useRuntimeCalls{*this, "use-runtime-calls", ::llvm::cl::desc("Generate runtime calls to a named set of conversion routines. By default, the conversions may produce unexpected results."), ::llvm::cl::init(std::string{})};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_CHARACTERCONVERSION
#endif // GEN_PASS_DEF_CHARACTERCONVERSION

//===----------------------------------------------------------------------===//
// ExternalNameConversion
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_EXTERNALNAMECONVERSION
struct ExternalNameConversionOptions {
  bool appendUnderscoreOpt = true;
};
#undef GEN_PASS_DECL_EXTERNALNAMECONVERSION
#endif // GEN_PASS_DECL_EXTERNALNAMECONVERSION
#ifdef GEN_PASS_DEF_EXTERNALNAMECONVERSION
namespace impl {

template <typename DerivedT>
class ExternalNameConversionBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = ExternalNameConversionBase;

  ExternalNameConversionBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ExternalNameConversionBase(const ExternalNameConversionBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("external-name-interop");
  }
  ::llvm::StringRef getArgument() const override { return "external-name-interop"; }

  ::llvm::StringRef getDescription() const override { return "Convert name for external interoperability"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ExternalNameConversion");
  }
  ::llvm::StringRef getName() const override { return "ExternalNameConversion"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ExternalNameConversionBase<DerivedT>)

  ExternalNameConversionBase(const ExternalNameConversionOptions &options) : ExternalNameConversionBase() {
    appendUnderscoreOpt = options.appendUnderscoreOpt;
  }
protected:
  ::mlir::Pass::Option<bool> appendUnderscoreOpt{*this, "append-underscore", ::llvm::cl::desc("Append trailing underscore to external names."), ::llvm::cl::init(true)};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_EXTERNALNAMECONVERSION
#endif // GEN_PASS_DEF_EXTERNALNAMECONVERSION

//===----------------------------------------------------------------------===//
// LoopVersioning
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_LOOPVERSIONING
#undef GEN_PASS_DECL_LOOPVERSIONING
#endif // GEN_PASS_DECL_LOOPVERSIONING
#ifdef GEN_PASS_DEF_LOOPVERSIONING
namespace impl {

template <typename DerivedT>
class LoopVersioningBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = LoopVersioningBase;

  LoopVersioningBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  LoopVersioningBase(const LoopVersioningBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("loop-versioning");
  }
  ::llvm::StringRef getArgument() const override { return "loop-versioning"; }

  ::llvm::StringRef getDescription() const override { return "Loop Versioning"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LoopVersioning");
  }
  ::llvm::StringRef getName() const override { return "LoopVersioning"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<fir::FIROpsDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LoopVersioningBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_LOOPVERSIONING
#endif // GEN_PASS_DEF_LOOPVERSIONING

//===----------------------------------------------------------------------===//
// MemRefDataFlowOpt
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_MEMREFDATAFLOWOPT
#undef GEN_PASS_DECL_MEMREFDATAFLOWOPT
#endif // GEN_PASS_DECL_MEMREFDATAFLOWOPT
#ifdef GEN_PASS_DEF_MEMREFDATAFLOWOPT
namespace impl {

template <typename DerivedT>
class MemRefDataFlowOptBase : public ::mlir::OperationPass<::mlir::func::FuncOp> {
public:
  using Base = MemRefDataFlowOptBase;

  MemRefDataFlowOptBase() : ::mlir::OperationPass<::mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  MemRefDataFlowOptBase(const MemRefDataFlowOptBase &other) : ::mlir::OperationPass<::mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("fir-memref-dataflow-opt");
  }
  ::llvm::StringRef getArgument() const override { return "fir-memref-dataflow-opt"; }

  ::llvm::StringRef getDescription() const override { return "Perform store/load forwarding and potentially removing dead stores."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("MemRefDataFlowOpt");
  }
  ::llvm::StringRef getName() const override { return "MemRefDataFlowOpt"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<fir::FIROpsDialect>();

  registry.insert<mlir::func::FuncDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(MemRefDataFlowOptBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_MEMREFDATAFLOWOPT
#endif // GEN_PASS_DEF_MEMREFDATAFLOWOPT

//===----------------------------------------------------------------------===//
// MemoryAllocationOpt
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_MEMORYALLOCATIONOPT
struct MemoryAllocationOptOptions {
  bool dynamicArrayOnHeap = false;
  std::size_t maxStackArraySize = ~static_cast<std::size_t>(0);
};
#undef GEN_PASS_DECL_MEMORYALLOCATIONOPT
#endif // GEN_PASS_DECL_MEMORYALLOCATIONOPT
#ifdef GEN_PASS_DEF_MEMORYALLOCATIONOPT
namespace impl {

template <typename DerivedT>
class MemoryAllocationOptBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = MemoryAllocationOptBase;

  MemoryAllocationOptBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  MemoryAllocationOptBase(const MemoryAllocationOptBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("memory-allocation-opt");
  }
  ::llvm::StringRef getArgument() const override { return "memory-allocation-opt"; }

  ::llvm::StringRef getDescription() const override { return "Convert stack to heap allocations and vice versa."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("MemoryAllocationOpt");
  }
  ::llvm::StringRef getName() const override { return "MemoryAllocationOpt"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<fir::FIROpsDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(MemoryAllocationOptBase<DerivedT>)

  MemoryAllocationOptBase(const MemoryAllocationOptOptions &options) : MemoryAllocationOptBase() {
    dynamicArrayOnHeap = options.dynamicArrayOnHeap;
    maxStackArraySize = options.maxStackArraySize;
  }
protected:
  ::mlir::Pass::Option<bool> dynamicArrayOnHeap{*this, "dynamic-array-on-heap", ::llvm::cl::desc("Allocate all arrays with runtime determined size on heap."), ::llvm::cl::init(false)};
  ::mlir::Pass::Option<std::size_t> maxStackArraySize{*this, "maximum-array-alloc-size", ::llvm::cl::desc("Set maximum number of elements of an array allocated on the stack."), ::llvm::cl::init(~static_cast<std::size_t>(0))};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_MEMORYALLOCATIONOPT
#endif // GEN_PASS_DEF_MEMORYALLOCATIONOPT

//===----------------------------------------------------------------------===//
// OMPEarlyOutliningPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_OMPEARLYOUTLININGPASS
#undef GEN_PASS_DECL_OMPEARLYOUTLININGPASS
#endif // GEN_PASS_DECL_OMPEARLYOUTLININGPASS
#ifdef GEN_PASS_DEF_OMPEARLYOUTLININGPASS
namespace impl {

template <typename DerivedT>
class OMPEarlyOutliningPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = OMPEarlyOutliningPassBase;

  OMPEarlyOutliningPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  OMPEarlyOutliningPassBase(const OMPEarlyOutliningPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("omp-early-target-outlining");
  }
  ::llvm::StringRef getArgument() const override { return "omp-early-target-outlining"; }

  ::llvm::StringRef getDescription() const override { return "Outlines all target ops into separate functions"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("OMPEarlyOutliningPass");
  }
  ::llvm::StringRef getName() const override { return "OMPEarlyOutliningPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(OMPEarlyOutliningPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_OMPEARLYOUTLININGPASS
#endif // GEN_PASS_DEF_OMPEARLYOUTLININGPASS

//===----------------------------------------------------------------------===//
// OMPFunctionFiltering
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_OMPFUNCTIONFILTERING
#undef GEN_PASS_DECL_OMPFUNCTIONFILTERING
#endif // GEN_PASS_DECL_OMPFUNCTIONFILTERING
#ifdef GEN_PASS_DEF_OMPFUNCTIONFILTERING
namespace impl {

template <typename DerivedT>
class OMPFunctionFilteringBase : public ::mlir::OperationPass<> {
public:
  using Base = OMPFunctionFilteringBase;

  OMPFunctionFilteringBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  OMPFunctionFilteringBase(const OMPFunctionFilteringBase &other) : ::mlir::OperationPass<>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("omp-function-filtering");
  }
  ::llvm::StringRef getArgument() const override { return "omp-function-filtering"; }

  ::llvm::StringRef getDescription() const override { return "Filters out functions intended for the host when compiling for the device and vice versa."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("OMPFunctionFiltering");
  }
  ::llvm::StringRef getName() const override { return "OMPFunctionFiltering"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<mlir::func::FuncDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(OMPFunctionFilteringBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_OMPFUNCTIONFILTERING
#endif // GEN_PASS_DEF_OMPFUNCTIONFILTERING

//===----------------------------------------------------------------------===//
// OMPMarkDeclareTargetPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_OMPMARKDECLARETARGETPASS
#undef GEN_PASS_DECL_OMPMARKDECLARETARGETPASS
#endif // GEN_PASS_DECL_OMPMARKDECLARETARGETPASS
#ifdef GEN_PASS_DEF_OMPMARKDECLARETARGETPASS
namespace impl {

template <typename DerivedT>
class OMPMarkDeclareTargetPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = OMPMarkDeclareTargetPassBase;

  OMPMarkDeclareTargetPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  OMPMarkDeclareTargetPassBase(const OMPMarkDeclareTargetPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("omp-mark-declare-target");
  }
  ::llvm::StringRef getArgument() const override { return "omp-mark-declare-target"; }

  ::llvm::StringRef getDescription() const override { return "Marks all functions called by an OpenMP declare target function as declare target"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("OMPMarkDeclareTargetPass");
  }
  ::llvm::StringRef getName() const override { return "OMPMarkDeclareTargetPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<mlir::omp::OpenMPDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(OMPMarkDeclareTargetPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_OMPMARKDECLARETARGETPASS
#endif // GEN_PASS_DEF_OMPMARKDECLARETARGETPASS

//===----------------------------------------------------------------------===//
// PolymorphicOpConversion
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_POLYMORPHICOPCONVERSION
#undef GEN_PASS_DECL_POLYMORPHICOPCONVERSION
#endif // GEN_PASS_DECL_POLYMORPHICOPCONVERSION
#ifdef GEN_PASS_DEF_POLYMORPHICOPCONVERSION
namespace impl {

template <typename DerivedT>
class PolymorphicOpConversionBase : public ::mlir::OperationPass<::mlir::func::FuncOp> {
public:
  using Base = PolymorphicOpConversionBase;

  PolymorphicOpConversionBase() : ::mlir::OperationPass<::mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  PolymorphicOpConversionBase(const PolymorphicOpConversionBase &other) : ::mlir::OperationPass<::mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("fir-polymorphic-op");
  }
  ::llvm::StringRef getArgument() const override { return "fir-polymorphic-op"; }

  ::llvm::StringRef getDescription() const override { return "Simplify operations on polymorphic types"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("PolymorphicOpConversion");
  }
  ::llvm::StringRef getName() const override { return "PolymorphicOpConversion"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<fir::FIROpsDialect>();

  registry.insert<mlir::func::FuncDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(PolymorphicOpConversionBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_POLYMORPHICOPCONVERSION
#endif // GEN_PASS_DEF_POLYMORPHICOPCONVERSION

//===----------------------------------------------------------------------===//
// SimplifyIntrinsics
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_SIMPLIFYINTRINSICS
struct SimplifyIntrinsicsOptions {
  bool enableExperimental = false;
};
#undef GEN_PASS_DECL_SIMPLIFYINTRINSICS
#endif // GEN_PASS_DECL_SIMPLIFYINTRINSICS
#ifdef GEN_PASS_DEF_SIMPLIFYINTRINSICS
namespace impl {

template <typename DerivedT>
class SimplifyIntrinsicsBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = SimplifyIntrinsicsBase;

  SimplifyIntrinsicsBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  SimplifyIntrinsicsBase(const SimplifyIntrinsicsBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("simplify-intrinsics");
  }
  ::llvm::StringRef getArgument() const override { return "simplify-intrinsics"; }

  ::llvm::StringRef getDescription() const override { return "Intrinsics simplification"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("SimplifyIntrinsics");
  }
  ::llvm::StringRef getName() const override { return "SimplifyIntrinsics"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(SimplifyIntrinsicsBase<DerivedT>)

  SimplifyIntrinsicsBase(const SimplifyIntrinsicsOptions &options) : SimplifyIntrinsicsBase() {
    enableExperimental = options.enableExperimental;
  }
protected:
  ::mlir::Pass::Option<bool> enableExperimental{*this, "enable-experimental", ::llvm::cl::desc("Enable experimental code that may not always work correctly"), ::llvm::cl::init(false)};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_SIMPLIFYINTRINSICS
#endif // GEN_PASS_DEF_SIMPLIFYINTRINSICS

//===----------------------------------------------------------------------===//
// SimplifyRegionLite
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_SIMPLIFYREGIONLITE
#undef GEN_PASS_DECL_SIMPLIFYREGIONLITE
#endif // GEN_PASS_DECL_SIMPLIFYREGIONLITE
#ifdef GEN_PASS_DEF_SIMPLIFYREGIONLITE
namespace impl {

template <typename DerivedT>
class SimplifyRegionLiteBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = SimplifyRegionLiteBase;

  SimplifyRegionLiteBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  SimplifyRegionLiteBase(const SimplifyRegionLiteBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("simplify-region-lite");
  }
  ::llvm::StringRef getArgument() const override { return "simplify-region-lite"; }

  ::llvm::StringRef getDescription() const override { return "Region simplification"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("SimplifyRegionLite");
  }
  ::llvm::StringRef getName() const override { return "SimplifyRegionLite"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(SimplifyRegionLiteBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_SIMPLIFYREGIONLITE
#endif // GEN_PASS_DEF_SIMPLIFYREGIONLITE

//===----------------------------------------------------------------------===//
// StackArrays
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_STACKARRAYS
#undef GEN_PASS_DECL_STACKARRAYS
#endif // GEN_PASS_DECL_STACKARRAYS
#ifdef GEN_PASS_DEF_STACKARRAYS
namespace impl {

template <typename DerivedT>
class StackArraysBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = StackArraysBase;

  StackArraysBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  StackArraysBase(const StackArraysBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("stack-arrays");
  }
  ::llvm::StringRef getArgument() const override { return "stack-arrays"; }

  ::llvm::StringRef getDescription() const override { return "Move local array allocations from heap memory into stack memory"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("StackArrays");
  }
  ::llvm::StringRef getName() const override { return "StackArrays"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<fir::FIROpsDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(StackArraysBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_STACKARRAYS
#endif // GEN_PASS_DEF_STACKARRAYS
#ifdef GEN_PASS_REGISTRATION

//===----------------------------------------------------------------------===//
// AbstractResultOnFuncOpt Registration
//===----------------------------------------------------------------------===//

inline void registerAbstractResultOnFuncOpt() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::fir::createAbstractResultOnFuncOptPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerAbstractResultOnFuncOptPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::fir::createAbstractResultOnFuncOptPass();
  });
}

//===----------------------------------------------------------------------===//
// AbstractResultOnGlobalOpt Registration
//===----------------------------------------------------------------------===//

inline void registerAbstractResultOnGlobalOpt() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::fir::createAbstractResultOnGlobalOptPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerAbstractResultOnGlobalOptPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::fir::createAbstractResultOnGlobalOptPass();
  });
}

//===----------------------------------------------------------------------===//
// AddDebugFoundation Registration
//===----------------------------------------------------------------------===//

inline void registerAddDebugFoundation() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::fir::createAddDebugFoundationPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerAddDebugFoundationPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::fir::createAddDebugFoundationPass();
  });
}

//===----------------------------------------------------------------------===//
// AffineDialectDemotion Registration
//===----------------------------------------------------------------------===//

inline void registerAffineDialectDemotion() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::fir::createAffineDemotionPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerAffineDialectDemotionPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::fir::createAffineDemotionPass();
  });
}

//===----------------------------------------------------------------------===//
// AffineDialectPromotion Registration
//===----------------------------------------------------------------------===//

inline void registerAffineDialectPromotion() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::fir::createPromoteToAffinePass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerAffineDialectPromotionPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::fir::createPromoteToAffinePass();
  });
}

//===----------------------------------------------------------------------===//
// AlgebraicSimplification Registration
//===----------------------------------------------------------------------===//

inline void registerAlgebraicSimplification() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::fir::createAlgebraicSimplificationPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerAlgebraicSimplificationPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::fir::createAlgebraicSimplificationPass();
  });
}

//===----------------------------------------------------------------------===//
// AnnotateConstantOperands Registration
//===----------------------------------------------------------------------===//

inline void registerAnnotateConstantOperands() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::fir::createAnnotateConstantOperandsPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerAnnotateConstantOperandsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::fir::createAnnotateConstantOperandsPass();
  });
}

//===----------------------------------------------------------------------===//
// ArrayValueCopy Registration
//===----------------------------------------------------------------------===//

inline void registerArrayValueCopy() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::fir::createArrayValueCopyPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerArrayValueCopyPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::fir::createArrayValueCopyPass();
  });
}

//===----------------------------------------------------------------------===//
// CFGConversion Registration
//===----------------------------------------------------------------------===//

inline void registerCFGConversion() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::fir::createFirToCfgPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerCFGConversionPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::fir::createFirToCfgPass();
  });
}

//===----------------------------------------------------------------------===//
// CharacterConversion Registration
//===----------------------------------------------------------------------===//

inline void registerCharacterConversion() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::fir::createCharacterConversionPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerCharacterConversionPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::fir::createCharacterConversionPass();
  });
}

//===----------------------------------------------------------------------===//
// ExternalNameConversion Registration
//===----------------------------------------------------------------------===//

inline void registerExternalNameConversion() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::fir::createExternalNameConversionPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerExternalNameConversionPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::fir::createExternalNameConversionPass();
  });
}

//===----------------------------------------------------------------------===//
// LoopVersioning Registration
//===----------------------------------------------------------------------===//

inline void registerLoopVersioning() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::fir::createLoopVersioningPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerLoopVersioningPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::fir::createLoopVersioningPass();
  });
}

//===----------------------------------------------------------------------===//
// MemRefDataFlowOpt Registration
//===----------------------------------------------------------------------===//

inline void registerMemRefDataFlowOpt() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::fir::createMemDataFlowOptPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerMemRefDataFlowOptPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::fir::createMemDataFlowOptPass();
  });
}

//===----------------------------------------------------------------------===//
// MemoryAllocationOpt Registration
//===----------------------------------------------------------------------===//

inline void registerMemoryAllocationOpt() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::fir::createMemoryAllocationPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerMemoryAllocationOptPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::fir::createMemoryAllocationPass();
  });
}

//===----------------------------------------------------------------------===//
// OMPEarlyOutliningPass Registration
//===----------------------------------------------------------------------===//

inline void registerOMPEarlyOutliningPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::fir::createOMPEarlyOutliningPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerOMPEarlyOutliningPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::fir::createOMPEarlyOutliningPass();
  });
}

//===----------------------------------------------------------------------===//
// OMPFunctionFiltering Registration
//===----------------------------------------------------------------------===//

inline void registerOMPFunctionFiltering() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::fir::createOMPFunctionFilteringPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerOMPFunctionFilteringPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::fir::createOMPFunctionFilteringPass();
  });
}

//===----------------------------------------------------------------------===//
// OMPMarkDeclareTargetPass Registration
//===----------------------------------------------------------------------===//

inline void registerOMPMarkDeclareTargetPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::fir::createOMPMarkDeclareTargetPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerOMPMarkDeclareTargetPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::fir::createOMPMarkDeclareTargetPass();
  });
}

//===----------------------------------------------------------------------===//
// PolymorphicOpConversion Registration
//===----------------------------------------------------------------------===//

inline void registerPolymorphicOpConversion() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::fir::createPolymorphicOpConversionPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerPolymorphicOpConversionPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::fir::createPolymorphicOpConversionPass();
  });
}

//===----------------------------------------------------------------------===//
// SimplifyIntrinsics Registration
//===----------------------------------------------------------------------===//

inline void registerSimplifyIntrinsics() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::fir::createSimplifyIntrinsicsPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerSimplifyIntrinsicsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::fir::createSimplifyIntrinsicsPass();
  });
}

//===----------------------------------------------------------------------===//
// SimplifyRegionLite Registration
//===----------------------------------------------------------------------===//

inline void registerSimplifyRegionLite() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::fir::createSimplifyRegionLitePass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerSimplifyRegionLitePass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::fir::createSimplifyRegionLitePass();
  });
}

//===----------------------------------------------------------------------===//
// StackArrays Registration
//===----------------------------------------------------------------------===//

inline void registerStackArrays() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::fir::createStackArraysPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerStackArraysPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::fir::createStackArraysPass();
  });
}

//===----------------------------------------------------------------------===//
// OptTransform Registration
//===----------------------------------------------------------------------===//

inline void registerOptTransformPasses() {
  registerAbstractResultOnFuncOpt();
  registerAbstractResultOnGlobalOpt();
  registerAddDebugFoundation();
  registerAffineDialectDemotion();
  registerAffineDialectPromotion();
  registerAlgebraicSimplification();
  registerAnnotateConstantOperands();
  registerArrayValueCopy();
  registerCFGConversion();
  registerCharacterConversion();
  registerExternalNameConversion();
  registerLoopVersioning();
  registerMemRefDataFlowOpt();
  registerMemoryAllocationOpt();
  registerOMPEarlyOutliningPass();
  registerOMPFunctionFiltering();
  registerOMPMarkDeclareTargetPass();
  registerPolymorphicOpConversion();
  registerSimplifyIntrinsics();
  registerSimplifyRegionLite();
  registerStackArrays();
}
#undef GEN_PASS_REGISTRATION
#endif // GEN_PASS_REGISTRATION
// Deprecated. Please use the new per-pass macros.
#ifdef GEN_PASS_CLASSES

template <typename DerivedT>
class AbstractResultOnFuncOptBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = AbstractResultOnFuncOptBase;

  AbstractResultOnFuncOptBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  AbstractResultOnFuncOptBase(const AbstractResultOnFuncOptBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("abstract-result-on-func-opt");
  }
  ::llvm::StringRef getArgument() const override { return "abstract-result-on-func-opt"; }

  ::llvm::StringRef getDescription() const override { return "Convert fir.array, fir.box and fir.rec function result to function argument"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("AbstractResultOnFuncOpt");
  }
  ::llvm::StringRef getName() const override { return "AbstractResultOnFuncOpt"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<fir::FIROpsDialect>();

  registry.insert<mlir::func::FuncDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(AbstractResultOnFuncOptBase<DerivedT>)

protected:
  ::mlir::Pass::Option<bool> passResultAsBox{*this, "abstract-result-as-box", ::llvm::cl::desc("Pass fir.array<T> result as fir.box<fir.array<T>> argument instead of fir.ref<fir.array<T>>."), ::llvm::cl::init(false)};
};

template <typename DerivedT>
class AbstractResultOnGlobalOptBase : public ::mlir::OperationPass<fir::GlobalOp> {
public:
  using Base = AbstractResultOnGlobalOptBase;

  AbstractResultOnGlobalOptBase() : ::mlir::OperationPass<fir::GlobalOp>(::mlir::TypeID::get<DerivedT>()) {}
  AbstractResultOnGlobalOptBase(const AbstractResultOnGlobalOptBase &other) : ::mlir::OperationPass<fir::GlobalOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("abstract-result-on-global-opt");
  }
  ::llvm::StringRef getArgument() const override { return "abstract-result-on-global-opt"; }

  ::llvm::StringRef getDescription() const override { return "Convert fir.array, fir.box and fir.rec function result to function argument"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("AbstractResultOnGlobalOpt");
  }
  ::llvm::StringRef getName() const override { return "AbstractResultOnGlobalOpt"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<fir::FIROpsDialect>();

  registry.insert<mlir::func::FuncDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(AbstractResultOnGlobalOptBase<DerivedT>)

protected:
  ::mlir::Pass::Option<bool> passResultAsBox{*this, "abstract-result-as-box", ::llvm::cl::desc("Pass fir.array<T> result as fir.box<fir.array<T>> argument instead of fir.ref<fir.array<T>>."), ::llvm::cl::init(false)};
};

template <typename DerivedT>
class AddDebugFoundationBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = AddDebugFoundationBase;

  AddDebugFoundationBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  AddDebugFoundationBase(const AddDebugFoundationBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("add-debug-foundation");
  }
  ::llvm::StringRef getArgument() const override { return "add-debug-foundation"; }

  ::llvm::StringRef getDescription() const override { return "Add the foundation for debug info"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("AddDebugFoundation");
  }
  ::llvm::StringRef getName() const override { return "AddDebugFoundation"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<fir::FIROpsDialect>();

  registry.insert<mlir::func::FuncDialect>();

  registry.insert<mlir::LLVM::LLVMDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(AddDebugFoundationBase<DerivedT>)

protected:
};

template <typename DerivedT>
class AffineDialectDemotionBase : public ::mlir::OperationPass<::mlir::func::FuncOp> {
public:
  using Base = AffineDialectDemotionBase;

  AffineDialectDemotionBase() : ::mlir::OperationPass<::mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  AffineDialectDemotionBase(const AffineDialectDemotionBase &other) : ::mlir::OperationPass<::mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("demote-affine");
  }
  ::llvm::StringRef getArgument() const override { return "demote-affine"; }

  ::llvm::StringRef getDescription() const override { return "Converts `affine.{load,store}` back to fir operations"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("AffineDialectDemotion");
  }
  ::llvm::StringRef getName() const override { return "AffineDialectDemotion"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<fir::FIROpsDialect>();

  registry.insert<mlir::func::FuncDialect>();

  registry.insert<mlir::affine::AffineDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(AffineDialectDemotionBase<DerivedT>)

protected:
};

template <typename DerivedT>
class AffineDialectPromotionBase : public ::mlir::OperationPass<::mlir::func::FuncOp> {
public:
  using Base = AffineDialectPromotionBase;

  AffineDialectPromotionBase() : ::mlir::OperationPass<::mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  AffineDialectPromotionBase(const AffineDialectPromotionBase &other) : ::mlir::OperationPass<::mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("promote-to-affine");
  }
  ::llvm::StringRef getArgument() const override { return "promote-to-affine"; }

  ::llvm::StringRef getDescription() const override { return "Promotes `fir.{do_loop,if}` to `affine.{for,if}`."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("AffineDialectPromotion");
  }
  ::llvm::StringRef getName() const override { return "AffineDialectPromotion"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<fir::FIROpsDialect>();

  registry.insert<mlir::func::FuncDialect>();

  registry.insert<mlir::affine::AffineDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(AffineDialectPromotionBase<DerivedT>)

protected:
};

template <typename DerivedT>
class AlgebraicSimplificationBase : public ::mlir::OperationPass<> {
public:
  using Base = AlgebraicSimplificationBase;

  AlgebraicSimplificationBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  AlgebraicSimplificationBase(const AlgebraicSimplificationBase &other) : ::mlir::OperationPass<>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("flang-algebraic-simplification");
  }
  ::llvm::StringRef getArgument() const override { return "flang-algebraic-simplification"; }

  ::llvm::StringRef getDescription() const override { return ""; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("AlgebraicSimplification");
  }
  ::llvm::StringRef getName() const override { return "AlgebraicSimplification"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<mlir::math::MathDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(AlgebraicSimplificationBase<DerivedT>)

protected:
};

template <typename DerivedT>
class AnnotateConstantOperandsBase : public ::mlir::OperationPass<> {
public:
  using Base = AnnotateConstantOperandsBase;

  AnnotateConstantOperandsBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  AnnotateConstantOperandsBase(const AnnotateConstantOperandsBase &other) : ::mlir::OperationPass<>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("annotate-constant");
  }
  ::llvm::StringRef getArgument() const override { return "annotate-constant"; }

  ::llvm::StringRef getDescription() const override { return "Annotate constant operands to all FIR operations"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("AnnotateConstantOperands");
  }
  ::llvm::StringRef getName() const override { return "AnnotateConstantOperands"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<fir::FIROpsDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(AnnotateConstantOperandsBase<DerivedT>)

protected:
};

template <typename DerivedT>
class ArrayValueCopyBase : public ::mlir::OperationPass<::mlir::func::FuncOp> {
public:
  using Base = ArrayValueCopyBase;

  ArrayValueCopyBase() : ::mlir::OperationPass<::mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  ArrayValueCopyBase(const ArrayValueCopyBase &other) : ::mlir::OperationPass<::mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("array-value-copy");
  }
  ::llvm::StringRef getArgument() const override { return "array-value-copy"; }

  ::llvm::StringRef getDescription() const override { return "Convert array value operations to memory operations."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ArrayValueCopy");
  }
  ::llvm::StringRef getName() const override { return "ArrayValueCopy"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<fir::FIROpsDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ArrayValueCopyBase<DerivedT>)

protected:
  ::mlir::Pass::Option<bool> optimizeConflicts{*this, "optimize-conflicts", ::llvm::cl::desc("do more detailed conflict analysis to reduce the number of temporaries"), ::llvm::cl::init(false)};
};

template <typename DerivedT>
class CFGConversionBase : public ::mlir::OperationPass<::mlir::func::FuncOp> {
public:
  using Base = CFGConversionBase;

  CFGConversionBase() : ::mlir::OperationPass<::mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  CFGConversionBase(const CFGConversionBase &other) : ::mlir::OperationPass<::mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("cfg-conversion");
  }
  ::llvm::StringRef getArgument() const override { return "cfg-conversion"; }

  ::llvm::StringRef getDescription() const override { return "Convert FIR structured control flow ops to CFG ops."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("CFGConversion");
  }
  ::llvm::StringRef getName() const override { return "CFGConversion"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<fir::FIROpsDialect>();

  registry.insert<mlir::func::FuncDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(CFGConversionBase<DerivedT>)

protected:
  ::mlir::Pass::Option<bool> forceLoopToExecuteOnce{*this, "always-execute-loop-body", ::llvm::cl::desc("force the body of a loop to execute at least once"), ::llvm::cl::init(false)};
};

template <typename DerivedT>
class CharacterConversionBase : public ::mlir::OperationPass<> {
public:
  using Base = CharacterConversionBase;

  CharacterConversionBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  CharacterConversionBase(const CharacterConversionBase &other) : ::mlir::OperationPass<>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("character-conversion");
  }
  ::llvm::StringRef getArgument() const override { return "character-conversion"; }

  ::llvm::StringRef getDescription() const override { return "Convert CHARACTER entities with different KINDs"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("CharacterConversion");
  }
  ::llvm::StringRef getName() const override { return "CharacterConversion"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<fir::FIROpsDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(CharacterConversionBase<DerivedT>)

protected:
  ::mlir::Pass::Option<std::string> useRuntimeCalls{*this, "use-runtime-calls", ::llvm::cl::desc("Generate runtime calls to a named set of conversion routines. By default, the conversions may produce unexpected results."), ::llvm::cl::init(std::string{})};
};

template <typename DerivedT>
class ExternalNameConversionBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = ExternalNameConversionBase;

  ExternalNameConversionBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ExternalNameConversionBase(const ExternalNameConversionBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("external-name-interop");
  }
  ::llvm::StringRef getArgument() const override { return "external-name-interop"; }

  ::llvm::StringRef getDescription() const override { return "Convert name for external interoperability"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ExternalNameConversion");
  }
  ::llvm::StringRef getName() const override { return "ExternalNameConversion"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ExternalNameConversionBase<DerivedT>)

protected:
  ::mlir::Pass::Option<bool> appendUnderscoreOpt{*this, "append-underscore", ::llvm::cl::desc("Append trailing underscore to external names."), ::llvm::cl::init(true)};
};

template <typename DerivedT>
class LoopVersioningBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = LoopVersioningBase;

  LoopVersioningBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  LoopVersioningBase(const LoopVersioningBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("loop-versioning");
  }
  ::llvm::StringRef getArgument() const override { return "loop-versioning"; }

  ::llvm::StringRef getDescription() const override { return "Loop Versioning"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LoopVersioning");
  }
  ::llvm::StringRef getName() const override { return "LoopVersioning"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<fir::FIROpsDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LoopVersioningBase<DerivedT>)

protected:
};

template <typename DerivedT>
class MemRefDataFlowOptBase : public ::mlir::OperationPass<::mlir::func::FuncOp> {
public:
  using Base = MemRefDataFlowOptBase;

  MemRefDataFlowOptBase() : ::mlir::OperationPass<::mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  MemRefDataFlowOptBase(const MemRefDataFlowOptBase &other) : ::mlir::OperationPass<::mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("fir-memref-dataflow-opt");
  }
  ::llvm::StringRef getArgument() const override { return "fir-memref-dataflow-opt"; }

  ::llvm::StringRef getDescription() const override { return "Perform store/load forwarding and potentially removing dead stores."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("MemRefDataFlowOpt");
  }
  ::llvm::StringRef getName() const override { return "MemRefDataFlowOpt"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<fir::FIROpsDialect>();

  registry.insert<mlir::func::FuncDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(MemRefDataFlowOptBase<DerivedT>)

protected:
};

template <typename DerivedT>
class MemoryAllocationOptBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = MemoryAllocationOptBase;

  MemoryAllocationOptBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  MemoryAllocationOptBase(const MemoryAllocationOptBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("memory-allocation-opt");
  }
  ::llvm::StringRef getArgument() const override { return "memory-allocation-opt"; }

  ::llvm::StringRef getDescription() const override { return "Convert stack to heap allocations and vice versa."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("MemoryAllocationOpt");
  }
  ::llvm::StringRef getName() const override { return "MemoryAllocationOpt"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<fir::FIROpsDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(MemoryAllocationOptBase<DerivedT>)

protected:
  ::mlir::Pass::Option<bool> dynamicArrayOnHeap{*this, "dynamic-array-on-heap", ::llvm::cl::desc("Allocate all arrays with runtime determined size on heap."), ::llvm::cl::init(false)};
  ::mlir::Pass::Option<std::size_t> maxStackArraySize{*this, "maximum-array-alloc-size", ::llvm::cl::desc("Set maximum number of elements of an array allocated on the stack."), ::llvm::cl::init(~static_cast<std::size_t>(0))};
};

template <typename DerivedT>
class OMPEarlyOutliningPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = OMPEarlyOutliningPassBase;

  OMPEarlyOutliningPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  OMPEarlyOutliningPassBase(const OMPEarlyOutliningPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("omp-early-target-outlining");
  }
  ::llvm::StringRef getArgument() const override { return "omp-early-target-outlining"; }

  ::llvm::StringRef getDescription() const override { return "Outlines all target ops into separate functions"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("OMPEarlyOutliningPass");
  }
  ::llvm::StringRef getName() const override { return "OMPEarlyOutliningPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(OMPEarlyOutliningPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class OMPFunctionFilteringBase : public ::mlir::OperationPass<> {
public:
  using Base = OMPFunctionFilteringBase;

  OMPFunctionFilteringBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  OMPFunctionFilteringBase(const OMPFunctionFilteringBase &other) : ::mlir::OperationPass<>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("omp-function-filtering");
  }
  ::llvm::StringRef getArgument() const override { return "omp-function-filtering"; }

  ::llvm::StringRef getDescription() const override { return "Filters out functions intended for the host when compiling for the device and vice versa."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("OMPFunctionFiltering");
  }
  ::llvm::StringRef getName() const override { return "OMPFunctionFiltering"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<mlir::func::FuncDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(OMPFunctionFilteringBase<DerivedT>)

protected:
};

template <typename DerivedT>
class OMPMarkDeclareTargetPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = OMPMarkDeclareTargetPassBase;

  OMPMarkDeclareTargetPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  OMPMarkDeclareTargetPassBase(const OMPMarkDeclareTargetPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("omp-mark-declare-target");
  }
  ::llvm::StringRef getArgument() const override { return "omp-mark-declare-target"; }

  ::llvm::StringRef getDescription() const override { return "Marks all functions called by an OpenMP declare target function as declare target"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("OMPMarkDeclareTargetPass");
  }
  ::llvm::StringRef getName() const override { return "OMPMarkDeclareTargetPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<mlir::omp::OpenMPDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(OMPMarkDeclareTargetPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class PolymorphicOpConversionBase : public ::mlir::OperationPass<::mlir::func::FuncOp> {
public:
  using Base = PolymorphicOpConversionBase;

  PolymorphicOpConversionBase() : ::mlir::OperationPass<::mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  PolymorphicOpConversionBase(const PolymorphicOpConversionBase &other) : ::mlir::OperationPass<::mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("fir-polymorphic-op");
  }
  ::llvm::StringRef getArgument() const override { return "fir-polymorphic-op"; }

  ::llvm::StringRef getDescription() const override { return "Simplify operations on polymorphic types"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("PolymorphicOpConversion");
  }
  ::llvm::StringRef getName() const override { return "PolymorphicOpConversion"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<fir::FIROpsDialect>();

  registry.insert<mlir::func::FuncDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(PolymorphicOpConversionBase<DerivedT>)

protected:
};

template <typename DerivedT>
class SimplifyIntrinsicsBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = SimplifyIntrinsicsBase;

  SimplifyIntrinsicsBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  SimplifyIntrinsicsBase(const SimplifyIntrinsicsBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("simplify-intrinsics");
  }
  ::llvm::StringRef getArgument() const override { return "simplify-intrinsics"; }

  ::llvm::StringRef getDescription() const override { return "Intrinsics simplification"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("SimplifyIntrinsics");
  }
  ::llvm::StringRef getName() const override { return "SimplifyIntrinsics"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(SimplifyIntrinsicsBase<DerivedT>)

protected:
  ::mlir::Pass::Option<bool> enableExperimental{*this, "enable-experimental", ::llvm::cl::desc("Enable experimental code that may not always work correctly"), ::llvm::cl::init(false)};
};

template <typename DerivedT>
class SimplifyRegionLiteBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = SimplifyRegionLiteBase;

  SimplifyRegionLiteBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  SimplifyRegionLiteBase(const SimplifyRegionLiteBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("simplify-region-lite");
  }
  ::llvm::StringRef getArgument() const override { return "simplify-region-lite"; }

  ::llvm::StringRef getDescription() const override { return "Region simplification"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("SimplifyRegionLite");
  }
  ::llvm::StringRef getName() const override { return "SimplifyRegionLite"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(SimplifyRegionLiteBase<DerivedT>)

protected:
};

template <typename DerivedT>
class StackArraysBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = StackArraysBase;

  StackArraysBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  StackArraysBase(const StackArraysBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("stack-arrays");
  }
  ::llvm::StringRef getArgument() const override { return "stack-arrays"; }

  ::llvm::StringRef getDescription() const override { return "Move local array allocations from heap memory into stack memory"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("StackArrays");
  }
  ::llvm::StringRef getName() const override { return "StackArrays"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<fir::FIROpsDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(StackArraysBase<DerivedT>)

protected:
};
#undef GEN_PASS_CLASSES
#endif // GEN_PASS_CLASSES
