/* Autogenerated by mlir-tblgen; don't manually edit */

#ifdef GEN_PASS_DECL
// Generate declarations for all passes.
#define GEN_PASS_DECL_BUFFERIZEHLFIR
#define GEN_PASS_DECL_CONVERTHLFIRTOFIR
#define GEN_PASS_DECL_INLINEELEMENTALS
#define GEN_PASS_DECL_LOWERHLFIRINTRINSICS
#define GEN_PASS_DECL_LOWERHLFIRORDEREDASSIGNMENTS
#define GEN_PASS_DECL_SIMPLIFYHLFIRINTRINSICS
#undef GEN_PASS_DECL
#endif // GEN_PASS_DECL

//===----------------------------------------------------------------------===//
// BufferizeHLFIR
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_BUFFERIZEHLFIR
#undef GEN_PASS_DECL_BUFFERIZEHLFIR
#endif // GEN_PASS_DECL_BUFFERIZEHLFIR
#ifdef GEN_PASS_DEF_BUFFERIZEHLFIR
namespace impl {

template <typename DerivedT>
class BufferizeHLFIRBase : public ::mlir::OperationPass<::mlir::ModuleOp> {
public:
  using Base = BufferizeHLFIRBase;

  BufferizeHLFIRBase() : ::mlir::OperationPass<::mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  BufferizeHLFIRBase(const BufferizeHLFIRBase &other) : ::mlir::OperationPass<::mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("bufferize-hlfir");
  }
  ::llvm::StringRef getArgument() const override { return "bufferize-hlfir"; }

  ::llvm::StringRef getDescription() const override { return "Convert HLFIR operations operating on hlfir.expr into operations on memory"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("BufferizeHLFIR");
  }
  ::llvm::StringRef getName() const override { return "BufferizeHLFIR"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(BufferizeHLFIRBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_BUFFERIZEHLFIR
#endif // GEN_PASS_DEF_BUFFERIZEHLFIR

//===----------------------------------------------------------------------===//
// ConvertHLFIRtoFIR
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_CONVERTHLFIRTOFIR
#undef GEN_PASS_DECL_CONVERTHLFIRTOFIR
#endif // GEN_PASS_DECL_CONVERTHLFIRTOFIR
#ifdef GEN_PASS_DEF_CONVERTHLFIRTOFIR
namespace impl {

template <typename DerivedT>
class ConvertHLFIRtoFIRBase : public ::mlir::OperationPass<::mlir::ModuleOp> {
public:
  using Base = ConvertHLFIRtoFIRBase;

  ConvertHLFIRtoFIRBase() : ::mlir::OperationPass<::mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertHLFIRtoFIRBase(const ConvertHLFIRtoFIRBase &other) : ::mlir::OperationPass<::mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-hlfir-to-fir");
  }
  ::llvm::StringRef getArgument() const override { return "convert-hlfir-to-fir"; }

  ::llvm::StringRef getDescription() const override { return "Lower High-Level FIR to FIR"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertHLFIRtoFIR");
  }
  ::llvm::StringRef getName() const override { return "ConvertHLFIRtoFIR"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertHLFIRtoFIRBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_CONVERTHLFIRTOFIR
#endif // GEN_PASS_DEF_CONVERTHLFIRTOFIR

//===----------------------------------------------------------------------===//
// InlineElementals
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_INLINEELEMENTALS
#undef GEN_PASS_DECL_INLINEELEMENTALS
#endif // GEN_PASS_DECL_INLINEELEMENTALS
#ifdef GEN_PASS_DEF_INLINEELEMENTALS
namespace impl {

template <typename DerivedT>
class InlineElementalsBase : public ::mlir::OperationPass<::mlir::func::FuncOp> {
public:
  using Base = InlineElementalsBase;

  InlineElementalsBase() : ::mlir::OperationPass<::mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  InlineElementalsBase(const InlineElementalsBase &other) : ::mlir::OperationPass<::mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("inline-elementals");
  }
  ::llvm::StringRef getArgument() const override { return "inline-elementals"; }

  ::llvm::StringRef getDescription() const override { return "Inline chained hlfir.elemental operations"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("InlineElementals");
  }
  ::llvm::StringRef getName() const override { return "InlineElementals"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(InlineElementalsBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_INLINEELEMENTALS
#endif // GEN_PASS_DEF_INLINEELEMENTALS

//===----------------------------------------------------------------------===//
// LowerHLFIRIntrinsics
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_LOWERHLFIRINTRINSICS
#undef GEN_PASS_DECL_LOWERHLFIRINTRINSICS
#endif // GEN_PASS_DECL_LOWERHLFIRINTRINSICS
#ifdef GEN_PASS_DEF_LOWERHLFIRINTRINSICS
namespace impl {

template <typename DerivedT>
class LowerHLFIRIntrinsicsBase : public ::mlir::OperationPass<::mlir::ModuleOp> {
public:
  using Base = LowerHLFIRIntrinsicsBase;

  LowerHLFIRIntrinsicsBase() : ::mlir::OperationPass<::mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  LowerHLFIRIntrinsicsBase(const LowerHLFIRIntrinsicsBase &other) : ::mlir::OperationPass<::mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("lower-hlfir-intrinsics");
  }
  ::llvm::StringRef getArgument() const override { return "lower-hlfir-intrinsics"; }

  ::llvm::StringRef getDescription() const override { return "Lower HLFIR transformational intrinsic operations"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LowerHLFIRIntrinsics");
  }
  ::llvm::StringRef getName() const override { return "LowerHLFIRIntrinsics"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LowerHLFIRIntrinsicsBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_LOWERHLFIRINTRINSICS
#endif // GEN_PASS_DEF_LOWERHLFIRINTRINSICS

//===----------------------------------------------------------------------===//
// LowerHLFIROrderedAssignments
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_LOWERHLFIRORDEREDASSIGNMENTS
struct LowerHLFIROrderedAssignmentsOptions {
  bool tryFusingAssignments = false;
};
#undef GEN_PASS_DECL_LOWERHLFIRORDEREDASSIGNMENTS
#endif // GEN_PASS_DECL_LOWERHLFIRORDEREDASSIGNMENTS
#ifdef GEN_PASS_DEF_LOWERHLFIRORDEREDASSIGNMENTS
namespace impl {

template <typename DerivedT>
class LowerHLFIROrderedAssignmentsBase : public ::mlir::OperationPass<::mlir::ModuleOp> {
public:
  using Base = LowerHLFIROrderedAssignmentsBase;

  LowerHLFIROrderedAssignmentsBase() : ::mlir::OperationPass<::mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  LowerHLFIROrderedAssignmentsBase(const LowerHLFIROrderedAssignmentsBase &other) : ::mlir::OperationPass<::mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("lower-hlfir-ordered-assignments");
  }
  ::llvm::StringRef getArgument() const override { return "lower-hlfir-ordered-assignments"; }

  ::llvm::StringRef getDescription() const override { return "Lower HLFIR ordered assignments like forall and where operations"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LowerHLFIROrderedAssignments");
  }
  ::llvm::StringRef getName() const override { return "LowerHLFIROrderedAssignments"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LowerHLFIROrderedAssignmentsBase<DerivedT>)

  LowerHLFIROrderedAssignmentsBase(const LowerHLFIROrderedAssignmentsOptions &options) : LowerHLFIROrderedAssignmentsBase() {
    tryFusingAssignments = options.tryFusingAssignments;
  }
protected:
  ::mlir::Pass::Option<bool> tryFusingAssignments{*this, "fuse-assignments", ::llvm::cl::desc("Fuse Forall and Where assignments in the same loop nest when legal.It is not clear yet if this is always beneficial. It may be best toleave this to later loop optimizations.Hence this is off by default."), ::llvm::cl::init(false)};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_LOWERHLFIRORDEREDASSIGNMENTS
#endif // GEN_PASS_DEF_LOWERHLFIRORDEREDASSIGNMENTS

//===----------------------------------------------------------------------===//
// SimplifyHLFIRIntrinsics
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_SIMPLIFYHLFIRINTRINSICS
#undef GEN_PASS_DECL_SIMPLIFYHLFIRINTRINSICS
#endif // GEN_PASS_DECL_SIMPLIFYHLFIRINTRINSICS
#ifdef GEN_PASS_DEF_SIMPLIFYHLFIRINTRINSICS
namespace impl {

template <typename DerivedT>
class SimplifyHLFIRIntrinsicsBase : public ::mlir::OperationPass<::mlir::func::FuncOp> {
public:
  using Base = SimplifyHLFIRIntrinsicsBase;

  SimplifyHLFIRIntrinsicsBase() : ::mlir::OperationPass<::mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  SimplifyHLFIRIntrinsicsBase(const SimplifyHLFIRIntrinsicsBase &other) : ::mlir::OperationPass<::mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("simplify-hlfir-intrinsics");
  }
  ::llvm::StringRef getArgument() const override { return "simplify-hlfir-intrinsics"; }

  ::llvm::StringRef getDescription() const override { return "Simplify HLFIR intrinsic operations that don't need to result in runtime calls"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("SimplifyHLFIRIntrinsics");
  }
  ::llvm::StringRef getName() const override { return "SimplifyHLFIRIntrinsics"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(SimplifyHLFIRIntrinsicsBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_SIMPLIFYHLFIRINTRINSICS
#endif // GEN_PASS_DEF_SIMPLIFYHLFIRINTRINSICS
#ifdef GEN_PASS_REGISTRATION

//===----------------------------------------------------------------------===//
// BufferizeHLFIR Registration
//===----------------------------------------------------------------------===//

inline void registerBufferizeHLFIR() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return hlfir::createBufferizeHLFIRPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerBufferizeHLFIRPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return hlfir::createBufferizeHLFIRPass();
  });
}

//===----------------------------------------------------------------------===//
// ConvertHLFIRtoFIR Registration
//===----------------------------------------------------------------------===//

inline void registerConvertHLFIRtoFIR() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return hlfir::createConvertHLFIRtoFIRPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerConvertHLFIRtoFIRPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return hlfir::createConvertHLFIRtoFIRPass();
  });
}

//===----------------------------------------------------------------------===//
// InlineElementals Registration
//===----------------------------------------------------------------------===//

inline void registerInlineElementals() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return hlfir::createInlineElementalsPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerInlineElementalsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return hlfir::createInlineElementalsPass();
  });
}

//===----------------------------------------------------------------------===//
// LowerHLFIRIntrinsics Registration
//===----------------------------------------------------------------------===//

inline void registerLowerHLFIRIntrinsics() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return hlfir::createLowerHLFIRIntrinsicsPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerLowerHLFIRIntrinsicsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return hlfir::createLowerHLFIRIntrinsicsPass();
  });
}

//===----------------------------------------------------------------------===//
// LowerHLFIROrderedAssignments Registration
//===----------------------------------------------------------------------===//

inline void registerLowerHLFIROrderedAssignments() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return hlfir::createLowerHLFIROrderedAssignmentsPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerLowerHLFIROrderedAssignmentsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return hlfir::createLowerHLFIROrderedAssignmentsPass();
  });
}

//===----------------------------------------------------------------------===//
// SimplifyHLFIRIntrinsics Registration
//===----------------------------------------------------------------------===//

inline void registerSimplifyHLFIRIntrinsics() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return hlfir::createSimplifyHLFIRIntrinsicsPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerSimplifyHLFIRIntrinsicsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return hlfir::createSimplifyHLFIRIntrinsicsPass();
  });
}

//===----------------------------------------------------------------------===//
// HLFIR Registration
//===----------------------------------------------------------------------===//

inline void registerHLFIRPasses() {
  registerBufferizeHLFIR();
  registerConvertHLFIRtoFIR();
  registerInlineElementals();
  registerLowerHLFIRIntrinsics();
  registerLowerHLFIROrderedAssignments();
  registerSimplifyHLFIRIntrinsics();
}
#undef GEN_PASS_REGISTRATION
#endif // GEN_PASS_REGISTRATION
// Deprecated. Please use the new per-pass macros.
#ifdef GEN_PASS_CLASSES

template <typename DerivedT>
class BufferizeHLFIRBase : public ::mlir::OperationPass<::mlir::ModuleOp> {
public:
  using Base = BufferizeHLFIRBase;

  BufferizeHLFIRBase() : ::mlir::OperationPass<::mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  BufferizeHLFIRBase(const BufferizeHLFIRBase &other) : ::mlir::OperationPass<::mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("bufferize-hlfir");
  }
  ::llvm::StringRef getArgument() const override { return "bufferize-hlfir"; }

  ::llvm::StringRef getDescription() const override { return "Convert HLFIR operations operating on hlfir.expr into operations on memory"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("BufferizeHLFIR");
  }
  ::llvm::StringRef getName() const override { return "BufferizeHLFIR"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(BufferizeHLFIRBase<DerivedT>)

protected:
};

template <typename DerivedT>
class ConvertHLFIRtoFIRBase : public ::mlir::OperationPass<::mlir::ModuleOp> {
public:
  using Base = ConvertHLFIRtoFIRBase;

  ConvertHLFIRtoFIRBase() : ::mlir::OperationPass<::mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertHLFIRtoFIRBase(const ConvertHLFIRtoFIRBase &other) : ::mlir::OperationPass<::mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-hlfir-to-fir");
  }
  ::llvm::StringRef getArgument() const override { return "convert-hlfir-to-fir"; }

  ::llvm::StringRef getDescription() const override { return "Lower High-Level FIR to FIR"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertHLFIRtoFIR");
  }
  ::llvm::StringRef getName() const override { return "ConvertHLFIRtoFIR"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertHLFIRtoFIRBase<DerivedT>)

protected:
};

template <typename DerivedT>
class InlineElementalsBase : public ::mlir::OperationPass<::mlir::func::FuncOp> {
public:
  using Base = InlineElementalsBase;

  InlineElementalsBase() : ::mlir::OperationPass<::mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  InlineElementalsBase(const InlineElementalsBase &other) : ::mlir::OperationPass<::mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("inline-elementals");
  }
  ::llvm::StringRef getArgument() const override { return "inline-elementals"; }

  ::llvm::StringRef getDescription() const override { return "Inline chained hlfir.elemental operations"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("InlineElementals");
  }
  ::llvm::StringRef getName() const override { return "InlineElementals"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(InlineElementalsBase<DerivedT>)

protected:
};

template <typename DerivedT>
class LowerHLFIRIntrinsicsBase : public ::mlir::OperationPass<::mlir::ModuleOp> {
public:
  using Base = LowerHLFIRIntrinsicsBase;

  LowerHLFIRIntrinsicsBase() : ::mlir::OperationPass<::mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  LowerHLFIRIntrinsicsBase(const LowerHLFIRIntrinsicsBase &other) : ::mlir::OperationPass<::mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("lower-hlfir-intrinsics");
  }
  ::llvm::StringRef getArgument() const override { return "lower-hlfir-intrinsics"; }

  ::llvm::StringRef getDescription() const override { return "Lower HLFIR transformational intrinsic operations"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LowerHLFIRIntrinsics");
  }
  ::llvm::StringRef getName() const override { return "LowerHLFIRIntrinsics"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LowerHLFIRIntrinsicsBase<DerivedT>)

protected:
};

template <typename DerivedT>
class LowerHLFIROrderedAssignmentsBase : public ::mlir::OperationPass<::mlir::ModuleOp> {
public:
  using Base = LowerHLFIROrderedAssignmentsBase;

  LowerHLFIROrderedAssignmentsBase() : ::mlir::OperationPass<::mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  LowerHLFIROrderedAssignmentsBase(const LowerHLFIROrderedAssignmentsBase &other) : ::mlir::OperationPass<::mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("lower-hlfir-ordered-assignments");
  }
  ::llvm::StringRef getArgument() const override { return "lower-hlfir-ordered-assignments"; }

  ::llvm::StringRef getDescription() const override { return "Lower HLFIR ordered assignments like forall and where operations"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LowerHLFIROrderedAssignments");
  }
  ::llvm::StringRef getName() const override { return "LowerHLFIROrderedAssignments"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LowerHLFIROrderedAssignmentsBase<DerivedT>)

protected:
  ::mlir::Pass::Option<bool> tryFusingAssignments{*this, "fuse-assignments", ::llvm::cl::desc("Fuse Forall and Where assignments in the same loop nest when legal.It is not clear yet if this is always beneficial. It may be best toleave this to later loop optimizations.Hence this is off by default."), ::llvm::cl::init(false)};
};

template <typename DerivedT>
class SimplifyHLFIRIntrinsicsBase : public ::mlir::OperationPass<::mlir::func::FuncOp> {
public:
  using Base = SimplifyHLFIRIntrinsicsBase;

  SimplifyHLFIRIntrinsicsBase() : ::mlir::OperationPass<::mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  SimplifyHLFIRIntrinsicsBase(const SimplifyHLFIRIntrinsicsBase &other) : ::mlir::OperationPass<::mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("simplify-hlfir-intrinsics");
  }
  ::llvm::StringRef getArgument() const override { return "simplify-hlfir-intrinsics"; }

  ::llvm::StringRef getDescription() const override { return "Simplify HLFIR intrinsic operations that don't need to result in runtime calls"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("SimplifyHLFIRIntrinsics");
  }
  ::llvm::StringRef getName() const override { return "SimplifyHLFIRIntrinsics"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(SimplifyHLFIRIntrinsicsBase<DerivedT>)

protected:
};
#undef GEN_PASS_CLASSES
#endif // GEN_PASS_CLASSES
